{"hash":"40ddb27da864f49af9fbdeee4ebe42b3ffad8e8a","data":{"post":{"title":"How I secured my data on my laptop","date":"2021.03.19","description":"By encrypting the root partition, detaching the LUKS header into a USB key, signing my own UEFI kernel, enabling secure boot, booting directly from firmware without any bootloader and locking the BIOS setup interface behind a password.","content":"<!-- TOC -->\n<ul>\n<li>\n<p><a href=\"#introduction\">Introduction</a></p>\n<ul>\n<li><a href=\"#credits-and-sources\">Credits and sources</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#root-encryption\">Root encryption</a></p>\n<ul>\n<li><a href=\"#create-a-new-partition-table\">Create a new partition table</a></li>\n<li><a href=\"#setup-luks\">Setup LUKS</a></li>\n<li><a href=\"#format-both-partitions\">Format both partitions</a></li>\n<li><a href=\"#overwrite-previous-data\">Overwrite previous data</a></li>\n<li><a href=\"#decrypt-partition-at-boot\">Decrypt partition at boot</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#secure-boot\">Secure boot</a></p>\n<ul>\n<li><a href=\"#generate-your-own-keys\">Generate your own keys</a></li>\n<li><a href=\"#generate-signed-unified-kernel\">Generate signed unified kernel</a></li>\n<li><a href=\"#enroll-keys-in-firmware\">Enroll keys in firmware</a></li>\n<li><a href=\"#bootloader\">Bootloader</a></li>\n</ul>\n</li>\n<li><a href=\"#recommendations\">Recommendations</a></li>\n</ul>\n<!-- /TOC -->\n<h1 id=\"introduction\"><a href=\"#introduction\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Introduction</h1>\n<p>Why ? You may ask. If like me, you like to work on your laptop from different places, then you may want to make sure that your sensitives data stay protected in case someone as a physical access to your computer.</p>\n<p>I'm not an expert in computer security. So please, be aware that my solution is not perfect and many vulnerabilities could still be exploited. Also, there's many different way to achieve this but I'll focus on only one method to avoid confusion.</p>\n<p>I have a 5 years old Dell XPS 15 and I'm using Arch Linux. It should works with another GNU/Linux distribution as the features used are mainly kernel related and the other packages are pretty common. However, the computer need to support EFI secure boot and being able to lock the BIOS setup interface behind a password.</p>\n<h2 id=\"credits-and-sources\"><a href=\"#credits-and-sources\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Credits and sources</h2>\n<ul>\n<li><a href=\"https://wiki.archlinux.org/index.php/Installation_guide\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ArchLinux Wiki: Installation guide</a></li>\n<li><a href=\"https://wiki.archlinux.org/index.php/Dm-crypt/Encrypting_an_entire_system#LUKS_on_LVM\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ArchLinux Wiki: Dm-crypt/LUKS on LVM</a></li>\n<li><a href=\"https://wiki.archlinux.org/index.php/Unified_Extensible_Firmware_Interface/Secure_Boot\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">ArchLinux Wiki: Unified Extensible Firmware Interface/Secure Boot</a></li>\n<li><a href=\"https://bentley.link/secureboot/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Matthew Bently: Combine the kernel, initramfs, and boot options</a></li>\n</ul>\n<h1 id=\"root-encryption\"><a href=\"#root-encryption\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Root encryption</h1>\n<p>Don't forget to verify the signature of your installation image as to avoid any malware from the start, then proceed with the <a href=\"https://wiki.archlinux.org/index.php/Installation_guide\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">installation</a> normally until you need to prepare your disk.</p>\n<h2 id=\"create-a-new-partition-table\"><a href=\"#create-a-new-partition-table\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Create a new partition table</h2>\n<p>Using <a href=\"https://wiki.archlinux.org/index.php/Fdisk\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><em>fdisk</em></a>, look for the name of your disk.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">fdisk</span> -l</code></pre>\n<p>In my case, having a NVMe SSD, my disk is named <strong>nvme0n1</strong> but otherwise, it's commonly named <strong>sda</strong>.</p>\n<table>\n<thead>\n<tr>\n<th>Name</th>\n<th>Type</th>\n<th>Size</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>/dev/sda1</td>\n<td>EFI</td>\n<td>512MB</td>\n</tr>\n<tr>\n<td>/dev/sda2</td>\n<td>Linux filesystem</td>\n<td>Remainder of the device</td>\n</tr>\n</tbody>\n</table>\n<p>That's how the partition table will look like if you follow my example. Normally, I like to use LVM as it offers more flexibility but I removed it to simplify. Also, I don't have a swap partition.</p>\n<p>Start <em>fdisk</em>.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">fdisk</span> /dev/sda</code></pre>\n<p>Inside the prompt:</p>\n<ol>\n<li>Type <strong>g</strong> to create a new empty GPT partition table.</li>\n<li>Type <strong>n</strong> to add a first partition.</li>\n<li>Type <strong>Enter</strong> a first time to accept the default partition number, then <strong>Enter</strong> a second time to accept the default first sector and finally <strong>+512M</strong> for the last sector.</li>\n<li>Type <strong>t</strong> then <strong>efi</strong> to change the type to 'EFI system'.</li>\n<li>Type <strong>n</strong> to add a second partition.</li>\n<li>Type <strong>Enter</strong> 3 times to accept all default values.</li>\n<li>Type <strong>w</strong> to save the changes and exit.</li>\n</ol>\n<h2 id=\"setup-luks\"><a href=\"#setup-luks\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Setup LUKS</h2>\n<p>I chose to detach the header into a USB key as a simple way to get a physical authentication factor. If your passphrase somehow leaked, your partition cannot be decrypted without the salt contained in the header. Also, even if someone had the computational power to break the encryption, it would make the process a bit harder.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">mount</span> /dev/sdb1 /mnt <span class=\"token comment\"># mount the usb</span>\ncryptsetup luksFormat /dev/sda2 --header /mnt/header.img\ncryptsetup <span class=\"token function\">open</span> /dev/sda2 root --header /mnt/header.img\n<span class=\"token function\">umount</span> /mnt</code></pre>\n<p>I strongly recommend making a backup of the header file somewhere safe. You cannot decrypt the root partition without it. So if your USB key fails, you'll lose all your data.</p>\n<h2 id=\"format-both-partitions\"><a href=\"#format-both-partitions\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Format both partitions</h2>\n<pre class=\"language-shell\"><code class=\"language-shell\">mkfs.vfat -F32 /dev/sda1\nmkfs.ext4 /dev/mapper/root</code></pre>\n<h2 id=\"overwrite-previous-data\"><a href=\"#overwrite-previous-data\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Overwrite previous data</h2>\n<p>This is a very long process depending of the size of your partition. If you don't do this, some old data could still be potentially retrieved.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">dd</span> <span class=\"token assign-left variable\">if</span><span class=\"token operator\">=</span>/dev/zero <span class=\"token assign-left variable\">of</span><span class=\"token operator\">=</span>/dev/mapper/root <span class=\"token assign-left variable\">status</span><span class=\"token operator\">=</span>progress</code></pre>\n<p>No need to use <code>/dev/random</code> because the encryption already turn the zeroes into random data.</p>\n<p><strong>Proceed with the rest of the installation and chroot into your new installation. Don't install any bootloader, the kernel will boot directly from the firmware.</strong></p>\n<h2 id=\"decrypt-partition-at-boot\"><a href=\"#decrypt-partition-at-boot\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Decrypt partition at boot</h2>\n<p>In order to decrypt your root partition at boot with a detached LUKS header on a usb key, add a custom hook to <em>initcpio</em>.</p>\n<p>I chose to use labels instead of GUIDs so I can use a backup USB key if the main one fails. So be aware that if there's another external drive connected to your laptop while booting, you may not be able to decrypt your root partition because of that.</p>\n<p><code>/etc/initcpio/hooks/customencrypt</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/usr/bin/ash</span>\n\n<span class=\"token function-name function\">run_hook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    modprobe -a -q dm-crypt <span class=\"token operator\">></span>/dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span>\n\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> -b <span class=\"token string\">'/dev/sdb1'</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n     <span class=\"token function\">sleep</span> <span class=\"token number\">1</span>\n    <span class=\"token keyword\">done</span>\n\n    <span class=\"token function\">mkdir</span> -p /mnt\n    <span class=\"token function\">mount</span> /dev/sdb1 /mnt\n    cryptsetup --header /mnt/header.img <span class=\"token function\">open</span> /dev/sda2 root\n    <span class=\"token function\">umount</span> /mnt\n<span class=\"token punctuation\">}</span></code></pre>\n<p><code>/etc/initcpio/install/customencrypt</code></p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token function-name function\">build</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token builtin class-name\">local</span> mod\n\n    add_module <span class=\"token string\">\"dm-crypt\"</span>\n    add_module <span class=\"token string\">\"dm-integrity\"</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token variable\">$CRYPTO_MODULES</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n        <span class=\"token keyword\">for</span> <span class=\"token for-or-select variable\">mod</span> <span class=\"token keyword\">in</span> <span class=\"token variable\">$CRYPTO_MODULES</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">do</span>\n            add_module <span class=\"token string\">\"<span class=\"token variable\">$mod</span>\"</span>\n        <span class=\"token keyword\">done</span>\n    <span class=\"token keyword\">else</span>\n        add_all_modules <span class=\"token string\">\"/crypto/\"</span>\n    <span class=\"token keyword\">fi</span>\n\n    add_binary <span class=\"token string\">\"cryptsetup\"</span>\n    add_binary <span class=\"token string\">\"dmsetup\"</span>\n    add_file <span class=\"token string\">\"/usr/lib/udev/rules.d/10-dm.rules\"</span>\n    add_file <span class=\"token string\">\"/usr/lib/udev/rules.d/13-dm-disk.rules\"</span>\n    add_file <span class=\"token string\">\"/usr/lib/udev/rules.d/95-dm-notify.rules\"</span>\n    add_file <span class=\"token string\">\"/usr/lib/initcpio/udev/11-dm-initramfs.rules\"</span> <span class=\"token string\">\"/usr/lib/udev/rules.d/11-dm-initramfs.rules\"</span>\n\n    <span class=\"token comment\"># cryptsetup calls pthread_create(), which dlopen()s libgcc_s.so.1</span>\n    add_binary <span class=\"token string\">\"/usr/lib/libgcc_s.so.1\"</span>\n\n    add_runscript\n<span class=\"token punctuation\">}</span></code></pre>\n<p>And finally, modify your <em>mkinitcpio</em> configuration file to add the custom module.</p>\n<p><code>/etc/mkinitcpio.conf</code></p>\n<pre class=\"language-text\"><code class=\"language-text\">HOOKS=(base udev autodetect keyboard keymap modconf block filesystems fsck customencrypt)</code></pre>\n<p>Use this mkinitcpio command to create your new initial ramdisk image.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">mkinitcpio -P</code></pre>\n<h1 id=\"secure-boot\"><a href=\"#secure-boot\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Secure boot</h1>\n<p>Why going through the hassle of enabling secure boot ? Well, your root partition is safe but your kernel is not. Imagine you let your laptop unsupervised a few minutes, someone could boot from a usb and replace your kernel with a custom one without you noticing. It's something you really don't want and I don't really need to explain why.</p>\n<p>Install the <em>sbsigntools</em> package.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">pacman -S sbsigntools</code></pre>\n<p>Create a new directory in a secure location like <code>/root/secureboot</code>.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">mkdir</span> /root/secureboot\n<span class=\"token builtin class-name\">cd</span> /root/secureboot</code></pre>\n<h2 id=\"generate-your-own-keys\"><a href=\"#generate-your-own-keys\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Generate your own keys</h2>\n<p>Create a script named <code>mkkeys.sh</code> that will automate the process.</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/bash</span>\n\n<span class=\"token builtin class-name\">echo</span> -n <span class=\"token string\">\"Enter a Common Name to embed in the keys: \"</span>\n<span class=\"token builtin class-name\">read</span> name\n\n<span class=\"token comment\">#GUID</span>\nuuidgen --random <span class=\"token operator\">></span> GUID.txt\n\n<span class=\"token comment\">#PLATFORM KEY</span>\nopenssl req -newkey rsa:4096 -nodes -keyout PK.key -new -x509 -sha256 -days <span class=\"token number\">3650</span> -subj <span class=\"token string\">\"/CN=<span class=\"token variable\">$name</span> PK/\"</span> -out PK.crt\nopenssl x509 -outform DER -in PK.crt -out PK.cer\ncert-to-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> PK.crt PK.esl\nsign-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> -k PK.key -c PK.crt PK PK.esl PK.auth\nsign-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> -c PK.crt -k PK.key PK /dev/null rm_PK.auth\n\n<span class=\"token comment\">#KEY EXCHANGE KEY</span>\nopenssl req -newkey rsa:4096 -nodes -keyout KEK.key -new -x509 -sha256 -days <span class=\"token number\">3650</span> -subj <span class=\"token string\">\"/CN=<span class=\"token variable\">$name</span> KEK/\"</span> -out KEK.crt\nopenssl x509 -outform DER -in KEK.crt -out KEK.cer\ncert-to-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> KEK.crt KEK.esl\nsign-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> -k PK.key -c PK.crt KEK KEK.esl KEK.auth\n\n<span class=\"token comment\">#SIGNATURE DATABASE KEY</span>\nopenssl req -newkey rsa:4096 -nodes -keyout db.key -new -x509 -sha256 -days <span class=\"token number\">3650</span> -subj <span class=\"token string\">\"/CN=<span class=\"token variable\">$name</span> db/\"</span> -out db.crt\nopenssl x509 -outform DER -in db.crt -out db.cer\ncert-to-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> db.crt db.esl\nsign-efi-sig-list -g <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token operator\">&lt;</span> GUID.txt<span class=\"token variable\">)</span></span>\"</span> -k KEK.key -c KEK.crt db db.esl db.auth</code></pre>\n<p>Then execute the script.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">touch</span> mkkeys.sh\n<span class=\"token function\">chmod</span> +x mkkeys.sh\n./mkkeys.sh</code></pre>\n<h2 id=\"generate-signed-unified-kernel\"><a href=\"#generate-signed-unified-kernel\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Generate signed unified kernel</h2>\n<p>Create a file named <code>cmdline.txt</code> containing the kernel parameters.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token assign-left variable\">BOOT_IMAGE</span><span class=\"token operator\">=</span>/vmlinuz-linux <span class=\"token assign-left variable\">initrd</span><span class=\"token operator\">=</span>/intel-ucode.img <span class=\"token assign-left variable\">initrd</span><span class=\"token operator\">=</span>/initramfs-linux.img <span class=\"token assign-left variable\">root</span><span class=\"token operator\">=</span>/dev/mapper/root</code></pre>\n<p>Notice that I'm using the <a href=\"https://wiki.archlinux.org/index.php/Microcode#Installation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Intel microcode</a>. If you don't have a Intel CPU or just don't want to use it, some modifications are required.</p>\n<p>Create a script named <code>mkkernel.sh</code>.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token shebang important\">#!/bin/sh</span>\n<span class=\"token builtin class-name\">cd</span> /root/secureboot\n\n<span class=\"token comment\">#COMBINE FILES</span>\n<span class=\"token function\">cat</span> /boot/intel-ucode.img /boot/initramfs-linux.img <span class=\"token operator\">></span> initramfs-linux.img\n<span class=\"token function\">cp</span> /boot/vmlinuz-linux <span class=\"token builtin class-name\">.</span>\n\nobjcopy <span class=\"token punctuation\">\\</span>\n    --add-section .osrel<span class=\"token operator\">=</span>/etc/os-release --change-section-vma .osrel<span class=\"token operator\">=</span>0x20000 <span class=\"token punctuation\">\\</span>\n    --add-section .cmdline<span class=\"token operator\">=</span><span class=\"token string\">\"cmdline.txt\"</span> --change-section-vma .cmdline<span class=\"token operator\">=</span>0x30000 <span class=\"token punctuation\">\\</span>\n    --add-section .linux<span class=\"token operator\">=</span><span class=\"token string\">\"vmlinuz-linux\"</span> --change-section-vma .linux<span class=\"token operator\">=</span>0x40000 <span class=\"token punctuation\">\\</span>\n    --add-section .initrd<span class=\"token operator\">=</span><span class=\"token string\">\"initramfs-linux.img\"</span> --change-section-vma .initrd<span class=\"token operator\">=</span>0x3000000 <span class=\"token punctuation\">\\</span>\n    /usr/lib/systemd/boot/efi/linuxx64.efi.stub kernel.efi\n\n<span class=\"token comment\">#SIGN EFI</span>\nsbsign --key db.key --cert db.crt --output kernel.efi.signed kernel.efi\n\n<span class=\"token comment\">#COPY KERNEL</span>\n<span class=\"token function\">cp</span> kernel.efi.signed /boot/kernel.efi</code></pre>\n<p>Make it executable.</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">touch</span> mkkernel.sh\n<span class=\"token function\">chmod</span> +x mkkernel.sh</code></pre>\n<p>You can manually execute the script each time you want to update the kernel but I recommend to automate the process with a pacman hook.</p>\n<p>Create a file at <code>/etc/pacman.d/hooks/91-secureboot.hook</code>.</p>\n<pre class=\"language-text\"><code class=\"language-text\">[Trigger]\nType = Path\nOperation = Install\nOperation = Upgrade\nTarget = usr/lib/modules/*/vmlinuz\nTarget = usr/lib/initcpio/*\n\n[Action]\nDescription = Making signed kernel UEFI\nWhen = PostTransaction\nExec = /root/secureboot/mkkernel.sh\nNeedsTargets</code></pre>\n<h2 id=\"enroll-keys-in-firmware\"><a href=\"#enroll-keys-in-firmware\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Enroll keys in firmware</h2>\n<p>I tried to use <strong>sbkeysync</strong> but despite being in setup mode, I was unable to enroll my keys so I had to enroll them manually, using my BIOS setup interface. Don't forget to enable secure boot mode in your BIOS setup interface and to lock it behind a password because if someone is able to simply turn it off, it would make all this pointless.</p>\n<h2 id=\"bootloader\"><a href=\"#bootloader\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Bootloader</h2>\n<p>I did not install any bootloader because it's simply useless in this case. Instead go into your BIOS setup interface and make a new boot entry for <code>kernel.efi</code>.</p>\n<h1 id=\"recommendations\"><a href=\"#recommendations\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Recommendations</h1>\n<ul>\n<li>I like to use a passphrase instead of password. It may be a bit longer to enter each time but it's easier to remember and save you the trouble of having to distinguish similar letters. Also a 8 word passphrase from a dictionary of 3600 words is stronger than a 8 long password from 60 different characters (3600^8 > 60^8).</li>\n<li>Use a idle screen locker and always lock your laptop before leaving it.</li>\n<li>Be aware of who might be looking at your screen/keyboard while you enter your passphrase.</li>\n<li>Don't let the usb key containing the LUKS header on your laptop. Remove it after the boot process and keep it with you.</li>\n</ul>\n"}},"context":{}}